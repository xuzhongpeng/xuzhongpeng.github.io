<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>「趣谈网络协议」笔记 | 幺风</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.da10bf32.css" as="style"><link rel="preload" href="/assets/js/app.f735c987.js" as="script"><link rel="preload" href="/assets/js/4.1b5f1a26.js" as="script"><link rel="preload" href="/assets/js/3.7354cf96.js" as="script"><link rel="preload" href="/assets/js/60.83d74725.js" as="script"><link rel="prefetch" href="/assets/js/1.91feba10.js"><link rel="prefetch" href="/assets/js/10.c31bcc1b.js"><link rel="prefetch" href="/assets/js/11.642edadc.js"><link rel="prefetch" href="/assets/js/12.e9bb10d9.js"><link rel="prefetch" href="/assets/js/13.bdd95be6.js"><link rel="prefetch" href="/assets/js/14.b6c81b34.js"><link rel="prefetch" href="/assets/js/15.b5139249.js"><link rel="prefetch" href="/assets/js/16.1ade8e0c.js"><link rel="prefetch" href="/assets/js/17.f0b30fb5.js"><link rel="prefetch" href="/assets/js/18.1c883b67.js"><link rel="prefetch" href="/assets/js/19.3e639663.js"><link rel="prefetch" href="/assets/js/20.74962acf.js"><link rel="prefetch" href="/assets/js/21.f837615d.js"><link rel="prefetch" href="/assets/js/22.933fde40.js"><link rel="prefetch" href="/assets/js/23.9334c5ee.js"><link rel="prefetch" href="/assets/js/24.ef408fc2.js"><link rel="prefetch" href="/assets/js/25.f9800b90.js"><link rel="prefetch" href="/assets/js/26.f56ce7bf.js"><link rel="prefetch" href="/assets/js/27.267e0efb.js"><link rel="prefetch" href="/assets/js/28.1aafaa74.js"><link rel="prefetch" href="/assets/js/29.bf71bb2d.js"><link rel="prefetch" href="/assets/js/30.65608550.js"><link rel="prefetch" href="/assets/js/31.c5de1bf4.js"><link rel="prefetch" href="/assets/js/32.43ee74a8.js"><link rel="prefetch" href="/assets/js/33.1efff8a5.js"><link rel="prefetch" href="/assets/js/34.89d049a4.js"><link rel="prefetch" href="/assets/js/35.6b5e7256.js"><link rel="prefetch" href="/assets/js/36.1be005db.js"><link rel="prefetch" href="/assets/js/37.db62ff97.js"><link rel="prefetch" href="/assets/js/38.5cf11128.js"><link rel="prefetch" href="/assets/js/39.fa355553.js"><link rel="prefetch" href="/assets/js/40.7490c5e3.js"><link rel="prefetch" href="/assets/js/41.4e813bfa.js"><link rel="prefetch" href="/assets/js/42.93650a8e.js"><link rel="prefetch" href="/assets/js/43.9f1ac82d.js"><link rel="prefetch" href="/assets/js/44.bd781139.js"><link rel="prefetch" href="/assets/js/45.2c5e635b.js"><link rel="prefetch" href="/assets/js/46.50f53b28.js"><link rel="prefetch" href="/assets/js/47.5478a007.js"><link rel="prefetch" href="/assets/js/48.ec71092b.js"><link rel="prefetch" href="/assets/js/49.f17a1618.js"><link rel="prefetch" href="/assets/js/5.4c86b808.js"><link rel="prefetch" href="/assets/js/50.b1e9909e.js"><link rel="prefetch" href="/assets/js/51.777f406a.js"><link rel="prefetch" href="/assets/js/52.f3a47314.js"><link rel="prefetch" href="/assets/js/53.8bda39e8.js"><link rel="prefetch" href="/assets/js/54.6bdd66b2.js"><link rel="prefetch" href="/assets/js/55.d3af29b9.js"><link rel="prefetch" href="/assets/js/56.5e98aed3.js"><link rel="prefetch" href="/assets/js/57.8fac4797.js"><link rel="prefetch" href="/assets/js/58.1f764b7f.js"><link rel="prefetch" href="/assets/js/59.cd677a6a.js"><link rel="prefetch" href="/assets/js/6.d79a3977.js"><link rel="prefetch" href="/assets/js/61.e61ccd9b.js"><link rel="prefetch" href="/assets/js/62.444cc809.js"><link rel="prefetch" href="/assets/js/63.157bbc00.js"><link rel="prefetch" href="/assets/js/64.2ec80c70.js"><link rel="prefetch" href="/assets/js/65.d35a0001.js"><link rel="prefetch" href="/assets/js/66.6f92e582.js"><link rel="prefetch" href="/assets/js/67.9d51e14d.js"><link rel="prefetch" href="/assets/js/68.5675c3e2.js"><link rel="prefetch" href="/assets/js/69.e536d7ac.js"><link rel="prefetch" href="/assets/js/7.0dcc7463.js"><link rel="prefetch" href="/assets/js/70.e187963b.js"><link rel="prefetch" href="/assets/js/71.09bda95d.js"><link rel="prefetch" href="/assets/js/72.aefd789f.js"><link rel="prefetch" href="/assets/js/73.20936a8d.js"><link rel="prefetch" href="/assets/js/74.d17921e6.js"><link rel="prefetch" href="/assets/js/75.0ff9c5e9.js"><link rel="prefetch" href="/assets/js/76.479d210c.js"><link rel="prefetch" href="/assets/js/77.c5443f0d.js"><link rel="prefetch" href="/assets/js/78.666b2fe9.js"><link rel="prefetch" href="/assets/js/79.949a1f44.js"><link rel="prefetch" href="/assets/js/8.67e8e6f2.js"><link rel="prefetch" href="/assets/js/9.70c87633.js">
    <link rel="stylesheet" href="/assets/css/0.styles.da10bf32.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container reform"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo.png" alt="幺风" class="logo"> <span class="site-name can-hide">幺风</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><span class="reform-jia" style="font-size:1rem;"></span>
主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="reform-zhi"></span> <span class="title">博文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/" class="nav-link"><!---->
前端</a></li><li class="dropdown-item"><!----> <a href="/blog/flutter/" class="nav-link"><!---->
Flutter</a></li><li class="dropdown-item"><!----> <a href="/blog/coding/" class="nav-link"><!---->
学习思考</a></li><li class="dropdown-item"><!----> <a href="/blog/algorithm/" class="nav-link"><!---->
算法与数据结构</a></li><li class="dropdown-item"><!----> <a href="/blog/reading/" class="nav-link router-link-active"><!---->
阅读笔记</a></li><li class="dropdown-item"><!----> <a href="/blog/reflection/" class="nav-link"><!---->
思考</a></li><li class="dropdown-item"><!----> <a href="/blog/canvas/" class="nav-link"><!---->
渲染相关</a></li><li class="dropdown-item"><!----> <a href="/blog/gesture/" class="nav-link"><!---->
事件相关</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="reform-shuben"></span> <span class="title">文档</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/document/vuepress-theme-reform.html" class="nav-link"><!---->
vuepress-theme-reform</a></li><li class="dropdown-item"><!----> <a href="/document/弹幕插件文档.html" class="nav-link"><!---->
弹幕插件文档</a></li></ul></div></div><div class="nav-item"><a href="/tags/" class="nav-link"><!---->
标签云</a></div><div class="nav-item"><a href="/about/" class="nav-link"><!---->
关于我</a></div> <a href="https://github.com/xuzhongpeng" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><span class="reform-jia" style="font-size:1rem;"></span>
主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="reform-zhi"></span> <span class="title">博文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/" class="nav-link"><!---->
前端</a></li><li class="dropdown-item"><!----> <a href="/blog/flutter/" class="nav-link"><!---->
Flutter</a></li><li class="dropdown-item"><!----> <a href="/blog/coding/" class="nav-link"><!---->
学习思考</a></li><li class="dropdown-item"><!----> <a href="/blog/algorithm/" class="nav-link"><!---->
算法与数据结构</a></li><li class="dropdown-item"><!----> <a href="/blog/reading/" class="nav-link router-link-active"><!---->
阅读笔记</a></li><li class="dropdown-item"><!----> <a href="/blog/reflection/" class="nav-link"><!---->
思考</a></li><li class="dropdown-item"><!----> <a href="/blog/canvas/" class="nav-link"><!---->
渲染相关</a></li><li class="dropdown-item"><!----> <a href="/blog/gesture/" class="nav-link"><!---->
事件相关</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="reform-shuben"></span> <span class="title">文档</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/document/vuepress-theme-reform.html" class="nav-link"><!---->
vuepress-theme-reform</a></li><li class="dropdown-item"><!----> <a href="/document/弹幕插件文档.html" class="nav-link"><!---->
弹幕插件文档</a></li></ul></div></div><div class="nav-item"><a href="/tags/" class="nav-link"><!---->
标签云</a></div><div class="nav-item"><a href="/about/" class="nav-link"><!---->
关于我</a></div> <a href="https://github.com/xuzhongpeng" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>「趣谈网络协议」笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#交换机与vlan" class="sidebar-link">交换机与VLAN</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#ping协议的格式" class="sidebar-link">Ping协议的格式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#静态路由协议" class="sidebar-link">静态路由协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#动态路由算法" class="sidebar-link">动态路由算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#距离矢量路由算法-distance-vector-routing" class="sidebar-link">距离矢量路由算法(distance vector routing)</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#链路状态路由算法（link-state-routing）" class="sidebar-link">链路状态路由算法（link state routing）</a></li></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#动态路由协议" class="sidebar-link">动态路由协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#_1-基于链路状态路由算法的ospf" class="sidebar-link">1. 基于链路状态路由算法的OSPF</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#_2-基于距离矢量路由算法的bgp" class="sidebar-link">2.基于距离矢量路由算法的BGP</a></li></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#udp协议" class="sidebar-link">UDP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#udp与tcp区别" class="sidebar-link">UDP与TCP区别</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#包头" class="sidebar-link">包头</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#特点" class="sidebar-link">特点</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#应用场景" class="sidebar-link">应用场景</a></li></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#tcp" class="sidebar-link">TCP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#tcp的三次握手" class="sidebar-link">TCP的三次握手</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#四次挥手" class="sidebar-link">四次挥手</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#tcp如何确定请求靠谱" class="sidebar-link">TCP如何确定请求靠谱</a></li></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#应用层，http协议" class="sidebar-link">应用层，HTTP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#当我们输入url访问网站到网页展示会经历什么" class="sidebar-link">当我们输入url访问网站到网页展示会经历什么</a></li></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#http-1-0与1-1区别" class="sidebar-link">HTTP 1.0与1.1区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#http-2-0" class="sidebar-link">HTTP 2.0</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#quic协议" class="sidebar-link">QUIC协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#https协议加密方式" class="sidebar-link">HTTPS协议加密方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#dns服务器" class="sidebar-link">DNS服务器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#dns服务器的树状结构：" class="sidebar-link">DNS服务器的树状结构：</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#解析流程" class="sidebar-link">解析流程</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#负载均衡" class="sidebar-link">负载均衡</a></li><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#dns服务器问题" class="sidebar-link">DNS服务器问题</a></li></ul></li><li><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#状态码" class="sidebar-link">状态码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/reading/%E3%80%8C%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8D%E7%AC%94%E8%AE%B0.html#_301、302、303、307、308区别" class="sidebar-link">301、302、303、307、308区别</a></li></ul></li></ul></section></li></ul> </aside> <main class="page" data-v-8958e280> <section class="tags" data-v-8958e280><span class="tagPopup" data-v-8958e280><a href="/tags/?tag=%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="tag" data-v-8958e280>读书笔记</a></span></section> <div class="content theme-default-content content__default" data-v-8958e280><h2 id="交换机与vlan"><a href="#交换机与vlan" aria-hidden="true" class="header-anchor">#</a> 交换机与VLAN</h2> <ul><li>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。交</li> <li>换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</li></ul> <h2 id="ping协议的格式"><a href="#ping协议的格式" aria-hidden="true" class="header-anchor">#</a> Ping协议的格式</h2> <ul><li>Ping是通过<code>ICMP</code>（Internet Control Message Protocol，互联网控制报文协议）协议工作的</li> <li>Ping比起原生的ICMP协议，多了两个字段，一个是<code>标识符</code>，区分用于不同功能，一个是<code>序号</code>，确定返回结果</li> <li>ICMP 相当于网络世界的侦察兵。有两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；</li> <li>ping 使用查询报文，Traceroute 使用差错报文。</li></ul> <h2 id="静态路由协议"><a href="#静态路由协议" aria-hidden="true" class="header-anchor">#</a> 静态路由协议</h2> <p>在真实的复杂的网络环境中，除了可以根据目的 ip 地址配置路由外，还可以根据多个参数来配置路由，这就称为<code>策略路由</code>。</p> <p>可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。</p> <h2 id="动态路由算法"><a href="#动态路由算法" aria-hidden="true" class="header-anchor">#</a> 动态路由算法</h2> <p>使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化</p> <p>路由器之间可以抽象出图，从而将问题转化为<code>如何找到图的最短路劲问题</code>.</p> <h3 id="距离矢量路由算法-distance-vector-routing"><a href="#距离矢量路由算法-distance-vector-routing" aria-hidden="true" class="header-anchor">#</a> 距离矢量路由算法(distance vector routing)</h3> <p>基于<code>Bellman-Ford</code>算法，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。</p> <p>问题：</p> <ul><li>其中有路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。</li> <li>每次发送广播的时候需要发送整个全局路由表，网络太大会造成拥堵。</li></ul> <h3 id="链路状态路由算法（link-state-routing）"><a href="#链路状态路由算法（link-state-routing）" aria-hidden="true" class="header-anchor">#</a> 链路状态路由算法（link state routing）</h3> <p>基于<code>Dijkstra</code>算法，当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。</p> <h2 id="动态路由协议"><a href="#动态路由协议" aria-hidden="true" class="header-anchor">#</a> 动态路由协议</h2> <h3 id="_1-基于链路状态路由算法的ospf"><a href="#_1-基于链路状态路由算法的ospf" aria-hidden="true" class="header-anchor">#</a> 1. 基于链路状态路由算法的OSPF</h3> <p><code>OSPF（Open Shortest Path First，开放式最短路径优先）</code>就是这样一个基于链路状态路由协议，广泛应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为内部网关协议（Interior Gateway Protocol，简称 IGP）。</p> <ul><li><code>内部网关协议</code>重点是找到最短路径。</li> <li>找到多个最短路径叫<code>等价路由</code>，可用于负债均衡</li></ul> <h3 id="_2-基于距离矢量路由算法的bgp"><a href="#_2-基于距离矢量路由算法的bgp" aria-hidden="true" class="header-anchor">#</a> 2.基于距离矢量路由算法的BGP</h3> <p>外网的路由协议，即国家之间的，又有所不同。称为`外网路由协议（Border Gateway Protocol，简称 BGP）</p> <ul><li>对于网络包，每个数据中心都设置自己的规则。哪些外部的IP可以让内部知晓，哪些内部的IP可以让外部知晓。</li> <li>网络中出现一个个自治系统<code>AS(Autonomous System)</code>,其分为几种类型：
<ul><li>Stub AS: 对外只有一个连接。不会传输其它AS的包。</li> <li>Multihomed AS:可能有多个连接连到其他的AS，但是大多拒绝帮其他的AS传输包。</li> <li>Transit AS: 有多个连接连到其它AS，并且可以帮助其它AS传输包。例如主干网</li></ul></li> <li>每个自治系统有边界路由器，与外界建立联系。</li> <li><code>BGP</code> 又分为两类，<code>eBGP</code> 和 <code>iBGP</code>。自治系统间，边界路由器之间使用 <code>eBGP</code> 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 <code>iBGP</code>，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。</li></ul> <h2 id="udp协议"><a href="#udp协议" aria-hidden="true" class="header-anchor">#</a> UDP协议</h2> <h3 id="udp与tcp区别"><a href="#udp与tcp区别" aria-hidden="true" class="header-anchor">#</a> UDP与TCP区别</h3> <ul><li>TCP 是面向连接的；UDP 是面向无连接的。</li> <li>TCP 提供可靠交付；UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。</li> <li>TCP 面向字节流；UPD基于数据报，一个个地发一个个地收</li> <li>TCP 是可以有拥塞控制的；UDP不会</li></ul> <h3 id="包头"><a href="#包头" aria-hidden="true" class="header-anchor">#</a> 包头</h3> <ul><li>IP头有8位协议，决定使用什么协议</li> <li>源端口号（16位）、目的端口号（16位）、UDP长度（16位）、UDP校验和（16位）、数据</li></ul> <h3 id="特点"><a href="#特点" aria-hidden="true" class="header-anchor">#</a> 特点</h3> <ul><li>沟通简单。数据结构、处理逻辑、包头简单。</li> <li>监听的端口谁都可以传输数据给他</li> <li>不会根据网络情况而改变</li></ul> <h3 id="应用场景"><a href="#应用场景" aria-hidden="true" class="header-anchor">#</a> 应用场景</h3> <ul><li>资源少的内网，对丢包不敏感的应用。如DHCP协议、TFTP</li> <li>不需要一对一沟通，建立连接，而是可以广播的应用。如DHCP、VXLAN</li> <li>需要处理速度快，延时低，可容忍少数丢包。如视频聊天、语音通话</li></ul> <h2 id="tcp"><a href="#tcp" aria-hidden="true" class="header-anchor">#</a> TCP</h2> <h3 id="tcp的三次握手"><a href="#tcp的三次握手" aria-hidden="true" class="header-anchor">#</a> TCP的三次握手</h3> <h4 id="为什么是三次？"><a href="#为什么是三次？" aria-hidden="true" class="header-anchor">#</a> 为什么是三次？</h4> <ul><li><ol><li>客户端A与服务器B建立连接，B发送应答包后是不能确定A已经收到</li></ol></li> <li><ol start="2"><li>当网络波动时，A会重复发送请求，B会重复应答</li></ol></li> <li><ol start="3"><li>三次握手可以确定双方都准备好了资源，避免死锁发生</li></ol></li></ul> <h3 id="四次挥手"><a href="#四次挥手" aria-hidden="true" class="header-anchor">#</a> 四次挥手</h3> <p>第一次：客户端请求断开FIN,seq=u</p> <p>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v</p> <p>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1</p> <p>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p> <h3 id="tcp如何确定请求靠谱"><a href="#tcp如何确定请求靠谱" aria-hidden="true" class="header-anchor">#</a> TCP如何确定请求靠谱</h3> <h4 id="每个包设置一个id，保证每个请求都有应答"><a href="#每个包设置一个id，保证每个请求都有应答" aria-hidden="true" class="header-anchor">#</a> 每个包设置一个ID，保证每个请求都有应答</h4> <h4 id="发送端根据处理情况设置四个部分："><a href="#发送端根据处理情况设置四个部分：" aria-hidden="true" class="header-anchor">#</a> 发送端根据处理情况设置四个部分：</h4> <ul><li><ol><li>发送了并且已经确认的。</li></ol></li> <li><ol start="2"><li>发送了并且尚未确定的</li></ol></li> <li><ol start="3"><li>没有发送等待发送的</li></ol></li> <li><ol start="4"><li>没有发送暂时不会发送（为了流量控制）</li></ol></li></ul> <h4 id="接收端三种情况："><a href="#接收端三种情况：" aria-hidden="true" class="header-anchor">#</a> 接收端三种情况：</h4> <ul><li><ol><li>接受并且确认过的</li></ol></li> <li><ol start="2"><li>还没接收，马上就能接受</li></ol></li> <li><ol start="3"><li>还没接收，也没法接收</li></ol></li></ul> <h4 id="确定与重发机制"><a href="#确定与重发机制" aria-hidden="true" class="header-anchor">#</a> 确定与重发机制</h4> <ol><li><p><strong>超时重试</strong></p> <p><code>自适应重传算法</code>:通过采样RTT的时间及RTT的波动范围，进行加权平均，算出一个值。超时间隔加倍，超过两次，说明网络太差，停止发送。</p></li> <li><p><strong>Selective Acknowledgment （SACK）</strong></p></li></ol> <p>在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方，发送方看到地图，就知道哪个包丢了。</p> <h4 id="流量控制问题"><a href="#流量控制问题" aria-hidden="true" class="header-anchor">#</a> 流量控制问题</h4> <h4 id="拥塞控制问题"><a href="#拥塞控制问题" aria-hidden="true" class="header-anchor">#</a> 拥塞控制问题</h4> <ol><li>设备缓存会导致延时？</li></ol> <ul><li>假如经过设备的包都不需要进入缓存，那么得到的速度是最快的。进入缓存且等待，等待的时间就是额外的延时。BBR就是为了避免这些问题：
充分利用带宽；降低buffer占用率。</li></ul> <ol start="2"><li><p>降低发送packet的速度，为何反而提速了？
标准TCP拥塞算法是遇到丢包的数据时快速下降发送速度，因为算法假设丢包都是因为过程设备缓存满了。快速下降后重新慢启动，整个过程对于带宽来说是浪费的。通过packet速度-时间的图来看，从积分上看，BBR充分利用带宽时发送效率才是最高的。可以说BBR比标准TCP拥塞算法更正确地处理了数据丢包。对于网络上有一定丢包率的公网，BBR会更加智慧一点。
回顾网络发展过程，带宽的是极大地改进的，而最小延迟会受限与介质传播速度，不会明显减少。BBR可以说是应运而生。</p></li> <li><p>BBR如何解决延时？</p></li></ol> <ul><li>S1：慢启动开始时，以前期的延迟时间为延迟最小值Tmin。然后监控延迟值是否达到Tmin的n倍，达到这个阀值后，判断带宽已经消耗尽且使用了一定的缓存，进入排空阶段。</li> <li>S2：指数降低发送速率，直至延迟不再降低。这个过程的原理同S1</li> <li>S3：协议进入稳定运行状态。交替探测带宽和延迟，且大多数时间下都处于带宽探测阶段。</li></ul> <h2 id="应用层，http协议"><a href="#应用层，http协议" aria-hidden="true" class="header-anchor">#</a> 应用层，HTTP协议</h2> <h3 id="当我们输入url访问网站到网页展示会经历什么"><a href="#当我们输入url访问网站到网页展示会经历什么" aria-hidden="true" class="header-anchor">#</a> 当我们输入url访问网站到网页展示会经历什么</h3> <ul><li>域名先通过DNS服务器解析成IP地址</li> <li>建立TCP连接（三次握手）</li> <li>请求构建:请求行、请求首部、正文实体</li> <li>通过二进制流发送</li> <li>TCP层将二进制流变成报文</li> <li>TCP发送报文段，用得到回应ACK来保证可靠地到达了对方。</li> <li>TCP发送每个报文的时候，加上自己的地址和目标地址放到IP头交给IP层传输</li> <li>IP层查看是否在同一个局域网，如果是，发送ARP协议来请求目标MAC地址；如果不是，发送ARP协议获取网关MAC地址，并把数据发送到网关</li> <li>网关收到取出目标IP地址，根据路由器协议找到下一跳的路由器，获取下一跳的路由器的MAC地址并发送给下一跳路由器</li> <li>到达目标地址的局域网，于是这个局域网发送ARP协议获取目标地址的MAC地址并发送到该地址</li> <li>目标机器发现了MAC地址符合，接收包，发现是IP协议，于是根据IP头中的协议项知道上层是TCP协议，于是按照TCP协议解析TCP的头，放入缓存中处理并返回一个ACK</li> <li>解析TCP的端口号，HTTP服务器监听此端口号，目标机器将包发送给目标端口，HTTP服务器进程响应到请求，返回找到对应资源</li> <li>服务器构建返回报文：状态吗、返回首部</li> <li>让TCP层将返回的HTML文件分为一个个小的段，加上TCP头交给IP层按来的过程再走一遍</li> <li>客户端发现接收报文，交给TCP层根据序列号处理是否符合，然后发给相应端口</li> <li>浏览器监听端口，取到状态码200，解析正文</li> <li>浏览器根据首部返回格式解析html格式数据，渲染执行</li></ul> <h2 id="http-1-0与1-1区别"><a href="#http-1-0与1-1区别" aria-hidden="true" class="header-anchor">#</a> HTTP 1.0与1.1区别</h2> <ul><li><p><code>缓存处理</code>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li> <li><p><code>带宽优化及网络连接的使用</code>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li> <li><p><code>错误通知的管理</code>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li> <li><p><code>Host头处理</code>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li> <li><p><code>长连接</code>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li></ul> <h2 id="http-2-0"><a href="#http-2-0" aria-hidden="true" class="header-anchor">#</a> HTTP 2.0</h2> <p>对比HTTP1.0优化：</p> <ol><li>对HTTP的头进行压缩，在两端建立索引表，对相同的头只发生索引表中的索引</li> <li>多路复用
<ul><li>HTTP2.0将TCP连接中，切分成多个流，每个流有自己的ID，它是一个虚拟通道，优先级更高</li> <li>对传输信息分割为更小的消息和帧，并采用二进制格式编码。传输header内容的帧<code>Header帧</code>,传输正文实体的帧<code>Data帧</code></li> <li>比如有三个请求，HTTP2.0会将它们分成三个流，将数据分成帧，乱序发送给TCP处理</li></ul></li> <li>服务器推送</li></ol> <h2 id="quic协议"><a href="#quic协议" aria-hidden="true" class="header-anchor">#</a> QUIC协议</h2> <p>解决问题：当服务端TCP层没有收到stream2的帧，即使是收到了后面的stream1的帧,stream1的帧也不会被传输到应用层中。基于TCP就突破不了TCP，各个帧虽然没有上下文的关联性，但是TCP强制他们的顺序性。</p> <ul><li>QUIC使用UDP进行传输</li> <li>QUIC自定义连接机制：通过自行维护连接机制生成一个ID作为标识，不会因为源 IP、源端口、目的 IP、目的端口一个变了就重新握手</li> <li>自定义重传机制：每发送一个包会带上不同序列号，通过offset来确定包是否接收到</li> <li>自定义流量控制</li></ul> <h2 id="https协议加密方式"><a href="#https协议加密方式" aria-hidden="true" class="header-anchor">#</a> HTTPS协议加密方式</h2> <ul><li>对称加密：加密和解密使用的密钥是相同的</li> <li>非对称加密：公钥加密的信息只能私钥能解密，私钥加密的信息只有公钥能解密</li> <li>数字证书</li></ul> <h2 id="dns服务器"><a href="#dns服务器" aria-hidden="true" class="header-anchor">#</a> DNS服务器</h2> <h3 id="dns服务器的树状结构："><a href="#dns服务器的树状结构：" aria-hidden="true" class="header-anchor">#</a> DNS服务器的树状结构：</h3> <ul><li><code>根 DNS 服务器</code>返回顶级域 DNS 服务器的 IP 地址</li> <li><code>顶级域 DNS 服务器</code>返回权威 DNS 服务器的 IP 地址</li> <li><code>权威 DNS 服务器</code>返回相应主机的 IP 地址</li></ul> <h3 id="解析流程"><a href="#解析流程" aria-hidden="true" class="header-anchor">#</a> 解析流程</h3> <ul><li>客户端发起DNS解析流程，先访问本地DNS缓存（/etc/hosts），无缓存</li> <li>客户端向本地DNS服务器（一般附近运营商的某个机房），无缓存</li> <li>本地DNS服务器访问根域名服务器，根域名服务器会返回顶级DNS服务器的IP地址</li> <li>本地DNS服务器拿到顶级DNS服务器IP地址，访问顶级DNS服务器地址，返回权威域名服务器IP地址</li> <li>本地DNS服务器拿到权威域名服务器IP地址，访问并拿到对应IP地址</li> <li>本地DNS服务器返回IP地址，客户端发起IP协议请求</li></ul> <h3 id="负载均衡"><a href="#负载均衡" aria-hidden="true" class="header-anchor">#</a> 负载均衡</h3> <ul><li><code>内部负载均衡</code>：1.重新映射域名即可更换服务器2.配置策略，可让解析时自动更换IP地址</li> <li><code>全局负载均衡</code>: 根据配置让DNS服务器自动返回附近的服务器的IP地址</li></ul> <h3 id="dns服务器问题"><a href="#dns服务器问题" aria-hidden="true" class="header-anchor">#</a> DNS服务器问题</h3> <ul><li>解析慢</li> <li>更新不及时</li> <li>因为缓存、转发、NAT问题导致客户端误会自己梭子啊的位置和运营商，影响流量调度</li></ul> <h2 id="状态码"><a href="#状态码" aria-hidden="true" class="header-anchor">#</a> 状态码</h2> <h3 id="_301、302、303、307、308区别"><a href="#_301、302、303、307、308区别" aria-hidden="true" class="header-anchor">#</a> 301、302、303、307、308区别</h3> <p>301、308都是永久重定向</p> <ul><li>301会将post请求转给get请求重新发送</li> <li>308会将原来的请求头和请求实体发送到新的地址</li></ul> <p>302、303、307是临时性重定向</p> <ul><li>302 客户端实现不一致，导致有些情况下会转 get请求再次请求，有些情况下会继续原来请求的方法</li> <li>303 为了解决302的问题，此状态码将会把所有请求方法转为get方法再次请求新请求</li> <li>307 将会原来的请求头请求体发送到新地址</li></ul></div> <footer class="page-edit" data-v-8958e280><!----> <div class="last-updated" data-v-8958e280><span class="prefix" data-v-8958e280>Last Updated:</span> <span class="time" data-v-8958e280>6/26/2021, 7:00:35 PM</span></div></footer> <!----> <div id="gitalk-container" data-v-8958e280></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.f735c987.js" defer></script><script src="/assets/js/4.1b5f1a26.js" defer></script><script src="/assets/js/3.7354cf96.js" defer></script><script src="/assets/js/60.83d74725.js" defer></script>
  </body>
</html>
