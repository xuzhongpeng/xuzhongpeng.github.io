(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{295:function(s,a,n){"use strict";n.r(a);var t=n(0),r=Object(t.a)({},function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"动态规划"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态规划","aria-hidden":"true"}},[s._v("#")]),s._v(" 动态规划")]),s._v(" "),n("h2",{attrs:{id:"动态规划原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态规划原理","aria-hidden":"true"}},[s._v("#")]),s._v(" 动态规划原理")]),s._v(" "),n("p",[n("strong",[s._v("基本思想：")]),s._v(" 问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题有较多的重复出现，则可以自底向上从最终子问题向原问题逐步求解。")]),s._v(" "),n("p",[n("strong",[s._v("使用条件：")]),s._v(" 可分为多个相关子问题，子问题的解被重复使用")]),s._v(" "),n("ul",[n("li",[s._v("Optimal substructure（优化子结构）：\n"),n("ul",[n("li",[s._v("一个问题的优化解包含了子问题的优化解")]),s._v(" "),n("li",[s._v("缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性")]),s._v(" "),n("li",[s._v("我们可以自下而上的")])])]),s._v(" "),n("li",[s._v("Subteties（重叠子问题）：在问题的求解过程中，很多子问题的解将被多次使用。")])]),s._v(" "),n("p",[n("strong",[s._v("动态规划算法的设计步骤：")])]),s._v(" "),n("ul",[n("li",[s._v("分析优化解的结构")]),s._v(" "),n("li",[s._v("递归地定义最优解的代价")]),s._v(" "),n("li",[s._v("自底向上地计算优化解的代价保存之，并获取构造最优解的信息")]),s._v(" "),n("li",[s._v("根据构造最优解的信息构造优化解\n"),n("strong",[s._v("动态规划特点：")])]),s._v(" "),n("li",[s._v("把原始问题划分成一系列子问题；")]),s._v(" "),n("li",[s._v("求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间")]),s._v(" "),n("li",[s._v("自底向上地计算。")]),s._v(" "),n("li",[s._v("整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）")])]),s._v(" "),n("h2",{attrs:{id:"步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#步骤","aria-hidden":"true"}},[s._v("#")]),s._v(" 步骤")]),s._v(" "),n("ul",[n("li",[s._v("问题拆解，找到问题之间的具体联系")]),s._v(" "),n("li",[s._v("状态定义")]),s._v(" "),n("li",[s._v("递推方程推导")]),s._v(" "),n("li",[s._v("实现")])]),s._v(" "),n("h2",{attrs:{id:"前提"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前提","aria-hidden":"true"}},[s._v("#")]),s._v(" 前提")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("最大问题能否划分为多个小问题")])]),s._v(" "),n("li",[n("p",[s._v("能否使用动态规划，取决于该问题是否能用动态规划解决的是这些"),n("code",[s._v("小问题")]),s._v("会不会被被重复调用。")])])]),s._v(" "),n("h2",{attrs:{id:"题型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题型","aria-hidden":"true"}},[s._v("#")]),s._v(" 题型")]),s._v(" "),n("h3",{attrs:{id:"_1-最大子序和"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-最大子序和","aria-hidden":"true"}},[s._v("#")]),s._v(" 1."),n("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-subarray/",target:"_blank",rel:"noopener noreferrer"}},[s._v(" 最大子序和"),n("OutboundLink")],1)]),s._v(" "),n("p",[s._v("给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。")]),s._v(" "),n("p",[s._v("示例:")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("进阶:")]),s._v("\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。")]),s._v(" "),n("p",[n("strong",[s._v("解题思路：")])]),s._v(" "),n("ul",[n("li",[s._v("动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans")]),s._v(" "),n("li",[s._v("如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字")]),s._v(" "),n("li",[s._v("如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字")]),s._v(" "),n("li",[s._v("每次比较 sum 和 ans 的大小，将最大值置为 ans，遍历结束返回结果")]),s._v(" "),n("li",[s._v("时间复杂度：O(n)O(n)")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var maxSubArray = function(nums) {\n    //存储最优结果\n    let result = nums[0]\n    //存储对最后结果有帮助的结果（只要大于0就有帮助）\n    let n = 0\n    for(let i=0;i<nums.length;i++){\n        if(n<0){\n            n = nums[i]\n        }else{\n            n += nums[i]\n        }\n        //result = Math.max(result,n)\n        if(result<n) result = n\n    }\n    return result\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])])])},[],!1,null,null,null);a.default=r.exports}}]);