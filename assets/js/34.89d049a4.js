(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{312:function(t,v,_){"use strict";_.r(v);var a=_(0),e=Object(a.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"计算机网络知识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络知识","aria-hidden":"true"}},[t._v("#")]),t._v(" 计算机网络知识")]),t._v(" "),_("h2",{attrs:{id:"tcp的3次握手和四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的3次握手和四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP的3次握手和四次挥手")]),t._v(" "),_("p",[t._v("三次握手：\n第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x")]),t._v(" "),_("p",[t._v("第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y")]),t._v(" "),_("p",[t._v("第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1")]),t._v(" "),_("h2",{attrs:{id:"四次挥手："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手：","aria-hidden":"true"}},[t._v("#")]),t._v(" 四次挥手：")]),t._v(" "),_("p",[t._v("第一次：客户端请求断开FIN,seq=u")]),t._v(" "),_("p",[t._v("第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v")]),t._v(" "),_("p",[t._v("第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1")]),t._v(" "),_("p",[t._v("第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1")]),t._v(" "),_("h2",{attrs:{id:"为什么连接的时候是三次握手，关闭的时候却是四次握手？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么连接的时候是三次握手，关闭的时候却是四次握手？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么连接的时候是三次握手，关闭的时候却是四次握手？")]),t._v(" "),_("p",[t._v('因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。')]),t._v(" "),_("h2",{attrs:{id:"为什么不能用两次握手进行连接？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能用两次握手进行连接？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么不能用两次握手进行连接？")]),t._v(" "),_("p",[t._v("3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。\n现在把三次握手改成仅需要两次握手，死锁是可能发生的。")]),t._v(" "),_("h2",{attrs:{id:"tcp与udp的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP与UDP的区别")]),t._v(" "),_("p",[t._v("tcp是面向连接的，由于tcp连接需要三次握手，所以能够最低限度的降低风险，保证连接的可靠性。\nudp 不是面向连接的，udp建立连接前不需要与对象建立连接，无论是发送还是接收，都没有发送确认信号。所以说udp是不可靠的。\n由于udp不需要进行确认连接，使得UDP的开销更小，传输速率更高，所以实时行更好。")]),t._v(" "),_("h2",{attrs:{id:"tcp与udp的应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp的应用","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP与UDP的应用")]),t._v(" "),_("p",[t._v("从特点上我们已经知道，TCP 是可靠的但传输速度慢 ，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。\n若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。")]),t._v(" "),_("h2",{attrs:{id:"http-https区别，此处延伸：https的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-https区别，此处延伸：https的实现原理","aria-hidden":"true"}},[t._v("#")]),t._v(" Http https区别，此处延伸：https的实现原理")]),t._v(" "),_("p",[t._v("1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。\n2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\n3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")]),t._v(" "),_("h2",{attrs:{id:"https实现原理："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https实现原理：","aria-hidden":"true"}},[t._v("#")]),t._v(" https实现原理：")]),t._v(" "),_("p",[t._v("（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。\n（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。\n（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n（5）Web服务器利用自己的私钥解密出会话密钥。\n（6）Web服务器利用会话密钥加密与客户端之间的通信。")]),t._v(" "),_("h2",{attrs:{id:"ip地址与mac地址区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ip地址与mac地址区别","aria-hidden":"true"}},[t._v("#")]),t._v(" IP地址与MAC地址区别")]),t._v(" "),_("ol",[_("li",[t._v("IP 是地址，有定位功能；MAC 是身份证，无定位功能；")]),t._v(" "),_("li",[t._v("MAC是每个电脑厂商出场时配置的，每个电脑的MAC地址不会变。IP地址是供应商分配的，跟网络有关。")])]),t._v(" "),_("h2",{attrs:{id:"http协议的method"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议的method","aria-hidden":"true"}},[t._v("#")]),t._v(" Http协议的method")]),t._v(" "),_("ul",[_("li",[t._v("GET 请求资源")]),t._v(" "),_("li",[t._v("HEAD 只请求页面首部")]),t._v(" "),_("li",[t._v("POST 提交资源")]),t._v(" "),_("li",[t._v("PUT 客户端向服务端传送数据文档内容")]),t._v(" "),_("li",[t._v("DELETE 删除指定页面")]),t._v(" "),_("li",[t._v("OPTIONS 查看服务器性能及302验证是否需要缓存更新")]),t._v(" "),_("li",[t._v("TRADE 请求服务器在响应中的实体主体部分返回所得的内容")])]),t._v(" "),_("h2",{attrs:{id:"状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态码","aria-hidden":"true"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),_("ul",[_("li",[t._v("200 OK：客户端请求成功。")]),t._v(" "),_("li",[t._v("301永久性重定向")]),t._v(" "),_("li",[t._v("302临时性重定向")]),t._v(" "),_("li",[t._v("304服务端已经执行了GET，但文件未变化")]),t._v(" "),_("li",[t._v("400 Bad Request：客户端请求有语法错误，不能被服务器所理解。")]),t._v(" "),_("li",[t._v("401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。")]),t._v(" "),_("li",[t._v("403 Forbidden：服务器收到请求，但是拒绝提供服务。")]),t._v(" "),_("li",[t._v("404 Not Found：请求资源不存在，举个例子：输入了错误的URL。")]),t._v(" "),_("li",[t._v("500 Internal Server Error：服务器发生不可预期的错误。")]),t._v(" "),_("li",[t._v("502 网关或代理错误")]),t._v(" "),_("li",[t._v("503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。")])]),t._v(" "),_("h3",{attrs:{id:"_301、302、303、307、308区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_301、302、303、307、308区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 301、302、303、307、308区别")]),t._v(" "),_("p",[t._v("301、308都是永久重定向")]),t._v(" "),_("ul",[_("li",[t._v("301会将post请求转给get请求重新发送")]),t._v(" "),_("li",[t._v("308会将原来的请求头和请求实体发送到新的地址")])]),t._v(" "),_("p",[t._v("302、303、307是临时性重定向")]),t._v(" "),_("ul",[_("li",[t._v("302 客户端实现不一致，导致有些情况下会转 get请求再次请求，有些情况下会继续原来请求的方法")]),t._v(" "),_("li",[t._v("303 为了解决302的问题，此状态码将会把所有请求方法转为get方法再次请求新请求")]),t._v(" "),_("li",[t._v("307 将会原来的请求头请求体发送到新地址")])]),t._v(" "),_("h2",{attrs:{id:"当我们输入url访问网站到网页展示会经历什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当我们输入url访问网站到网页展示会经历什么","aria-hidden":"true"}},[t._v("#")]),t._v(" 当我们输入url访问网站到网页展示会经历什么")]),t._v(" "),_("ul",[_("li",[t._v("域名先通过DNS服务器解析成IP地址")]),t._v(" "),_("li",[t._v("建立TCP连接（三次握手）")]),t._v(" "),_("li",[t._v("请求构建:请求行、请求首部、正文实体")]),t._v(" "),_("li",[t._v("通过二进制流发送")]),t._v(" "),_("li",[t._v("TCP层将二进制流变成报文")]),t._v(" "),_("li",[t._v("TCP发送报文段，用得到回应ACK来保证可靠地到达了对方。")]),t._v(" "),_("li",[t._v("TCP发送每个报文的时候，加上自己的地址和目标地址放到IP头交给IP层传输")]),t._v(" "),_("li",[t._v("IP层查看是否在同一个局域网，如果是，发送ARP协议来请求目标MAC地址；如果不是，发送ARP协议获取网关MAC地址，并把数据发送到网关")]),t._v(" "),_("li",[t._v("网关收到取出目标IP地址，根据路由器协议找到下一跳的路由器，获取下一跳的路由器的MAC地址并发送给下一跳路由器")]),t._v(" "),_("li",[t._v("到达目标地址的局域网，于是这个局域网发送ARP协议获取目标地址的MAC地址并发送到该地址")]),t._v(" "),_("li",[t._v("目标机器发现了MAC地址符合，接收包，发现是IP协议，于是根据IP头中的协议项知道上层是TCP协议，于是按照TCP协议解析TCP的头，放入缓存中处理并返回一个ACK")]),t._v(" "),_("li",[t._v("解析TCP的端口号，HTTP服务器监听此端口号，目标机器将包发送给目标端口，HTTP服务器进程响应到请求，返回找到对应资源")]),t._v(" "),_("li",[t._v("服务器构建返回报文：状态吗、返回首部")]),t._v(" "),_("li",[t._v("让TCP层将返回的HTML文件分为一个个小的段，加上TCP头交给IP层按来的过程再走一遍")]),t._v(" "),_("li",[t._v("客户端发现接收报文，交给TCP层根据序列号处理是否符合，然后发给相应端口")]),t._v(" "),_("li",[t._v("浏览器监听端口，取到状态码200，解析正文")]),t._v(" "),_("li",[t._v("浏览器根据首部返回格式解析html格式数据，渲染执行")])]),t._v(" "),_("h2",{attrs:{id:"http-1-0与1-1区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0与1-1区别","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP 1.0与1.1区别")]),t._v(" "),_("ul",[_("li",[_("p",[_("code",[t._v("缓存处理")]),t._v("，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("带宽优化及网络连接的使用")]),t._v("，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("错误通知的管理")]),t._v("，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("Host头处理")]),t._v("，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("长连接")]),t._v("，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。")])])]),t._v(" "),_("h2",{attrs:{id:"http-2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP 2.0")]),t._v(" "),_("p",[t._v("对比HTTP1.0优化：")]),t._v(" "),_("ol",[_("li",[t._v("对HTTP的头进行压缩，在两端建立索引表，对相同的头只发生索引表中的索引")]),t._v(" "),_("li",[t._v("多路复用\n"),_("ul",[_("li",[t._v("HTTP2.0将TCP连接中，切分成多个流，每个流有自己的ID，它是一个虚拟通道，优先级更高")]),t._v(" "),_("li",[t._v("对传输信息分割为更小的消息和帧，并采用二进制格式编码。传输header内容的帧"),_("code",[t._v("Header帧")]),t._v(",传输正文实体的帧"),_("code",[t._v("Data帧")])]),t._v(" "),_("li",[t._v("比如有三个请求，HTTP2.0会将它们分成三个流，将数据分成帧，乱序发送给TCP处理")])])])]),t._v(" "),_("h2",{attrs:{id:"https协议加密方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https协议加密方式","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTPS协议加密方式")]),t._v(" "),_("ul",[_("li",[t._v("对称加密：加密和解密使用的密钥是相同的")]),t._v(" "),_("li",[t._v("非对称加密：公钥加密的信息只能私钥能解密，私钥加密的信息只有公钥能解密")]),t._v(" "),_("li",[t._v("数字证书")])]),t._v(" "),_("h2",{attrs:{id:"dns服务器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns服务器","aria-hidden":"true"}},[t._v("#")]),t._v(" DNS服务器")]),t._v(" "),_("h3",{attrs:{id:"dns服务器的树状结构："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns服务器的树状结构：","aria-hidden":"true"}},[t._v("#")]),t._v(" DNS服务器的树状结构：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("根 DNS 服务器")]),t._v("返回顶级域 DNS 服务器的 IP 地址")]),t._v(" "),_("li",[_("code",[t._v("顶级域 DNS 服务器")]),t._v("返回权威 DNS 服务器的 IP 地址")]),t._v(" "),_("li",[_("code",[t._v("权威 DNS 服务器")]),t._v("返回相应主机的 IP 地址")])]),t._v(" "),_("h3",{attrs:{id:"解析流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解析流程","aria-hidden":"true"}},[t._v("#")]),t._v(" 解析流程")]),t._v(" "),_("ul",[_("li",[t._v("客户端发起DNS解析流程，先访问本地DNS缓存（/etc/hosts），无缓存")]),t._v(" "),_("li",[t._v("客户端向本地DNS服务器（一般附近运营商的某个机房），无缓存")]),t._v(" "),_("li",[t._v("本地DNS服务器访问根域名服务器，根域名服务器会返回顶级DNS服务器的IP地址")]),t._v(" "),_("li",[t._v("本地DNS服务器拿到顶级DNS服务器IP地址，访问顶级DNS服务器地址，返回权威域名服务器IP地址")]),t._v(" "),_("li",[t._v("本地DNS服务器拿到权威域名服务器IP地址，访问并拿到对应IP地址")]),t._v(" "),_("li",[t._v("本地DNS服务器返回IP地址，客户端发起IP协议请求")])]),t._v(" "),_("h3",{attrs:{id:"负载均衡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡","aria-hidden":"true"}},[t._v("#")]),t._v(" 负载均衡")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("内部负载均衡")]),t._v("：1.重新映射域名即可更换服务器2.配置策略，可让解析时自动更换IP地址")]),t._v(" "),_("li",[_("code",[t._v("全局负载均衡")]),t._v(": 根据配置让DNS服务器自动返回附近的服务器的IP地址")])]),t._v(" "),_("h3",{attrs:{id:"dns服务器问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns服务器问题","aria-hidden":"true"}},[t._v("#")]),t._v(" DNS服务器问题")]),t._v(" "),_("ul",[_("li",[t._v("解析慢")]),t._v(" "),_("li",[t._v("更新不及时")]),t._v(" "),_("li",[t._v("因为缓存、转发、NAT问题导致客户端误会自己梭子啊的位置和运营商，影响流量调度")])]),t._v(" "),_("h2",{attrs:{id:"websocket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#websocket","aria-hidden":"true"}},[t._v("#")]),t._v(" websocket")]),t._v(" "),_("ol",[_("li",[t._v("longpoll 客户端一直发送消息，服务端接受消息才返回")]),t._v(" "),_("li",[t._v("轮询 客户端一直发送消息，服务端一直返回")])]),t._v(" "),_("p",[t._v("websocket是基于TCP的一个协议，可以让服务端对数据进行推送。")])])},[],!1,null,null,null);v.default=e.exports}}]);