(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{301:function(t,s,v){"use strict";v.r(s);var _=v(0),a=Object(_.a)({},function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"贪心算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪心算法")]),t._v(" "),v("h2",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),v("p",[t._v("所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。")]),t._v(" "),v("p",[t._v("贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，"),v("strong",[t._v("选择的贪心策略必须具备无后效性")]),t._v("（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）")]),t._v(" "),v("p",[v("strong",[t._v("所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。")])]),t._v(" "),v("h2",{attrs:{id:"基本思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本思路","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本思路")]),t._v(" "),v("ul",[v("li",[t._v("建立数学模型来描述问题")]),t._v(" "),v("li",[t._v("把求解的问题分成若干个子问题")]),t._v(" "),v("li",[t._v("对每个子问题求解，得到子问题的局部最优解")]),t._v(" "),v("li",[t._v("把子问题的解局部最优解合成原来问题的一个解")])]),t._v(" "),v("h2",{attrs:{id:"存在问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存在问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 存在问题")]),t._v(" "),v("ul",[v("li",[t._v("不能保证求得的最后解是最佳的")]),t._v(" "),v("li",[t._v("不能用来求最大值或最小值的问题")]),t._v(" "),v("li",[t._v("只能求满足某些约束条件的可行解的范围")])]),t._v(" "),v("h2",{attrs:{id:"贪心算法适用的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法适用的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪心算法适用的问题")]),t._v(" "),v("p",[t._v("适用前提："),v("strong",[t._v("局部最优策略能导致产生全局最优解。")])]),t._v(" "),v("p",[t._v("实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。")]),t._v(" "),v("h2",{attrs:{id:"贪心算法的实现框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法的实现框架","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪心算法的实现框架")]),t._v(" "),v("p",[t._v("从问题的某一初始解出发：\nwhile (朝给定总目标前进一步)\n{\n利用可行的决策，求出可行解的一个解元素。\n}\n由所有解元素组合成问题的一个可行解；")]),t._v(" "),v("h2",{attrs:{id:"背包问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#背包问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 背包问题")]),t._v(" "),v("p",[t._v("问题：【背包问题】有一个背包，容量是 M=150，有 7 个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。\n物品： A B C D E F G\n重量：35 30 60 50 40 10 25\n价值：10 40 30 50 35 40 30")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("物品")]),t._v(" "),v("th",[t._v("A")]),t._v(" "),v("th",[t._v("B")]),t._v(" "),v("th",[t._v("C")]),t._v(" "),v("th",[t._v("D")]),t._v(" "),v("th",[t._v("E")]),t._v(" "),v("th",[t._v("F")]),t._v(" "),v("th",[t._v("G")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("重量：")]),t._v(" "),v("td",[t._v("35")]),t._v(" "),v("td",[t._v("30")]),t._v(" "),v("td",[t._v("60")]),t._v(" "),v("td",[t._v("50")]),t._v(" "),v("td",[t._v("40")]),t._v(" "),v("td",[t._v("10")]),t._v(" "),v("td",[t._v("25")])]),t._v(" "),v("tr",[v("td",[t._v("价值：")]),t._v(" "),v("td",[t._v("10")]),t._v(" "),v("td",[t._v("40")]),t._v(" "),v("td",[t._v("30")]),t._v(" "),v("td",[t._v("50")]),t._v(" "),v("td",[t._v("35")]),t._v(" "),v("td",[t._v("40")]),t._v(" "),v("td",[t._v("30")])])])]),t._v(" "),v("p",[t._v("分析：\n目标函数： ∑pi 最大\n约束条件是装入的物品总质量不超过背包容量：∑wi<=M( M=150)\n（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？\n（2）每次挑选所占重量最小的物品装入是否能得到最优解？\n（3）每次选取单位重量价值最大的物品，成为解本题的策略\n值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。比如，求最小生成树的 Prim 算法和 Kruskal 算法都是漂亮的贪心算法。\n贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。\n可惜的是，它需要证明后才能真正运用到题目的算法中。\n一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。\n对于例题中的 3 种贪心策略，都是无法成立（无法被证明）的，解释如下：\n贪心策略：选取价值最大者。反例：")]),t._v(" "),v("p",[t._v("W=30")]),t._v(" "),v("p",[t._v("物品：A B C")]),t._v(" "),v("p",[t._v("重量：28 12 12")]),t._v(" "),v("p",[t._v("价值：30 20 20")]),t._v(" "),v("p",[t._v("根据策略，首先选取物品 A，接下来就无法再选取了，可是，选取 B、C 则更好。")]),t._v(" "),v("p",[t._v("（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。")]),t._v(" "),v("p",[t._v("（3）贪心策略：选取单位重量价值最大的物品。反例：")]),t._v(" "),v("p",[t._v("W=30")]),t._v(" "),v("p",[t._v("物品：A B C")]),t._v(" "),v("p",[t._v("重量：28 20 10")]),t._v(" "),v("p",[t._v("价值：28 20 10")]),t._v(" "),v("p",[t._v("根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择 A，则答案错误。但是果在条件中加一句当遇见单位价值相同的时候,优先装重量小的,这样的问题就可以解决.")]),t._v(" "),v("p",[t._v("所以需要说明的是，贪心算法可以与随机化算法一起使用，具体的例子就不再多举了。（因为这一类算法普及性不高，而且技术含量是非常高的，需要通过一些反例确定随机的对象是什么，随机程度如何，但也是不能保证完全正确，只能是极大的几率正确）。")]),t._v(" "),v("h2",{attrs:{id:"集合覆盖问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集合覆盖问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 集合覆盖问题")]),t._v(" "),v("p",[t._v("集合覆盖问题： 选择最少的集合，覆盖全部的元素。\n假设你办了个广播节目，要让全美 505050 个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("广播台")]),t._v(" "),v("th",[t._v("覆盖的州")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("(1) KONE")]),t._v(" "),v("td",[t._v("ID，NV，UT")])]),t._v(" "),v("tr",[v("td",[t._v("(2) KTWO")]),t._v(" "),v("td",[t._v("WA，ID，MT")])]),t._v(" "),v("tr",[v("td",[t._v("(3) KTHREE")]),t._v(" "),v("td",[t._v("OR，NV，CA")])]),t._v(" "),v("tr",[v("td",[t._v("(4) KFOUR")]),t._v(" "),v("td",[t._v("NV，UT")])]),t._v(" "),v("tr",[v("td",[t._v("(5) KFIVE")]),t._v(" "),v("td",[t._v("CA，ZA")])])])]),t._v(" "),v("p",[t._v("如何找出覆盖全美 505050 个州的最小广播台集合呢？\n最容易考虑到的可能是暴力求解法：列出每一种可能的广播集合（可能的子集有 2n2^n2\nn\n个）；在这些集合中选出能覆盖全美 505050 个州的最小集合数。假设每秒可筛选出 101010 个子集，其花费的时间如下：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://vnode-1253495453.cos.ap-nanjing.myqcloud.com/%E8%A6%86%E7%9B%96%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98.png",alt:""}})]),t._v(" "),v("p",[t._v("没有任何算法可以足够快地解决这个问题！怎么办呢？使用贪婪算法可以得到非常接近的解。")]),t._v(" "),v("ol",[v("li",[t._v("选出这样一个广播台，即它覆盖了最多的未被选择的州。即便这个广播台覆盖了一些已经选择的州，也没有关系；")]),t._v(" "),v("li",[t._v("重复第一步，直到覆盖了所有的州。")])]),t._v(" "),v("p",[t._v("贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为 O(n2)O(n^2)O(n^2)，其中 n 为广播台数量。")]),t._v(" "),v("p",[t._v("解决上述问题的代码如下：")]),t._v(" "),v("ul",[v("li",[t._v("第一步：准备工作：构建数据结构；\n"),v("ul",[v("li",[t._v("用集合 states_needed 存储所有的州；")]),t._v(" "),v("li",[t._v("用字典表示电视台 stations 的覆盖面；")])])])]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('states_needed = set([\'mt\', \'wa\', \'or\', \'id\', \'nv\', \'ut\', \'ca\', \'az\']) # 包含要覆盖的州\n\nstations = {} # 存储电视台集合\nstations["kone"] = set(["id", "nv", "ut"])\nstations["ktwo"] = set(["wa", "id", "mt"])\nstations["kthree"] = set(["or", "nv", "ca"])\nstations["kfour"] = set(["nv", "ut"])\nstations["kfive"] = set(["ca", "az"])\n\nfinal_stations = set() # 存储最终电视台的集合\n')])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br")])]),v("ul",[v("li",[t._v("第二步：利用贪心算法求解最少的电视台\n"),v("ul",[v("li",[t._v("选出这样一个广播台，即它覆盖了最多的未被选择的州。我们将这个广播台存储在 best_station 中；")]),t._v(" "),v("li",[t._v("重复第一步，直到覆盖了所有的州。")])])])]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("while states_needed:\n    best_station = None # 最佳电视台:覆盖了最多未覆盖的州\n    states_covered = set() # 最佳电视台与未覆盖州集合的交集\n    for station, states in stations.items():\n        covered = states_needed & states # 当前广播台与未覆盖州集合的交集\n        if len(covered) > len(states_covered):\n            states_covered = covered\n            best_station = station\n\n    states_needed -= states_covered # 更新未覆盖州的集合\n    final_stations.add(best_station) # 添加贪心算法选择的电台\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br")])]),v("p",[t._v("最终打印的结果可能如下：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("print(final_stations)\n# set(['ktwo', 'kthree', 'kone', 'kfive'])\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[t._v("暴力求解算法 和 贪心算法 求解时间对比：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://vnode-1253495453.cos.ap-nanjing.myqcloud.com/%E6%9A%B4%E5%8A%9B%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"np-完全问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#np-完全问题","aria-hidden":"true"}},[t._v("#")]),t._v(" NP 完全问题")]),t._v(" "),v("p",[t._v("对于 NP 完全问题的定义，百度百科是这样给出的：NP 完全问题(NP-C 问题)，是世界七大数学难题之一。 NP 的英文全称是 Non-deterministic Polynomial 的问题，即多项式复杂程度的非确定性问题。简单的写法是 NP=P？，问题就在这个问号上，到底是 NP 等于 P，还是 NP 不等于 P。")]),t._v(" "),v("p",[t._v("通俗地来说，有些计算问题是确定性的，比如加减乘除之类，你只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来的。一般这种无法按部就班计算出来的问题，只能通过穷举法等暴力的方法来解决。")]),t._v(" "),v("h2",{attrs:{id:"如何识别-np-完全问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何识别-np-完全问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何识别 NP 完全问题")]),t._v(" "),v("p",[t._v("既然 NP 完全问题是多项式复杂程度的非确定性问题，简言之就是难解决的问题，自然也是难判别的。")]),t._v(" "),v("p",[t._v("其实，根本没有一个定理来判断一个问题是否是 NP 完全问题。只是，还是有很多线索可以帮助我们来做识别的。这些线索罗列如下：")]),t._v(" "),v("ul",[v("li",[t._v("元素较少时算法的运行速度非常快，但随着元素数目的增加，速度会变得非常慢。")]),t._v(" "),v("li",[t._v("涉及“所有组合”的问题通常是 NP 完全问题。")]),t._v(" "),v("li",[t._v("不能采用分治法的思想将大问题分解成小问题，必须考虑各种可能情况，这很可能是 NP 完全问题。")]),t._v(" "),v("li",[t._v("如果问题涉及“序列”或“集合”，并难以解决，很可能就是 NP 完全问题。")]),t._v(" "),v("li",[t._v("如果问题可转换为旅行商问题或集合覆盖问题，那就肯定是 NP 完全问题。")])]),t._v(" "),v("h2",{attrs:{id:"用最少数量的箭引爆气球"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用最少数量的箭引爆气球","aria-hidden":"true"}},[t._v("#")]),t._v(" 用最少数量的箭引爆气球")]),t._v(" "),v("p",[t._v("https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\n在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。")]),t._v(" "),v("p",[t._v("一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。")]),t._v(" "),v("p",[t._v("给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。")]),t._v(" "),v("p",[t._v("示例 1：")]),t._v(" "),v("p",[t._v("输入：points = [[10,16],[2,8],[1,6],[7,12]]\n输出：2\n解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球\n示例 2：")]),t._v(" "),v("p",[t._v("输入：points = [[1,2],[3,4],[5,6],[7,8]]\n输出：4\n示例 3：")]),t._v(" "),v("p",[t._v("输入：points = [[1,2],[2,3],[3,4],[4,5]]\n输出：2\n示例 4：")]),t._v(" "),v("p",[t._v("输入：points = [[1,2]]\n输出：1\n示例 5：")]),t._v(" "),v("p",[t._v("输入：points = [[2,3],[2,3]]\n输出：1")])])},[],!1,null,null,null);s.default=a.exports}}]);