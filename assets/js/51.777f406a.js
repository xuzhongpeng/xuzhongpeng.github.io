(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{336:function(a,r,t){"use strict";t.r(r);var e=t(0),v=Object(e.a)({},function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),t("p",[a._v("很多人都知道v8引擎，v8引擎是一种js引擎的实现。在开始介绍v8之前，先搞清JavaScript引擎是什么，这里简单引用")]),a._v(" "),t("p",[a._v("JavaScript引擎是执行JavaScript代码的程序或解释器。javaScript引擎可以实现为标准解释器或即时编译器，它以某种形式将JavaScript编译为字节码。")]),a._v(" "),t("ul",[t("li",[a._v("V8 - 开源，由Google开发，用C ++编写")]),a._v(" "),t("li",[a._v("Rhin- 由Mozilla基金会开源，完全用Java开发")]),a._v(" "),t("li",[a._v("SpiderMonkey 第一个JavaScript引擎，Netscape Navigator，Firefox")]),a._v(" "),t("li",[a._v("JavaScriptCore 苹果公司为Safari开发")]),a._v(" "),t("li",[a._v("KJS 最初由Harri Porten为KDE项目的Konqueror网络浏览器开发")]),a._v(" "),t("li",[a._v("Chakra** (JScript9) Microsoft Edge")]),a._v(" "),t("li",[a._v("Chakra** (JavaScript) Microsoft IE9-IE11")]),a._v(" "),t("li",[a._v("Nashorn 作为OpenJDK的一部分，由Oracle Java语言和工具组编写")]),a._v(" "),t("li",[a._v("JerryScript 一个物联网的轻量级引擎\n")])]),a._v(" "),t("h2",{attrs:{id:"数据表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据表示","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据表示")]),a._v(" "),t("p",[a._v("JavaScript是一种无类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。")]),a._v(" "),t("p",[a._v("在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。")]),a._v(" "),t("h2",{attrs:{id:"隐藏类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐藏类","aria-hidden":"true"}},[a._v("#")]),a._v(" 隐藏类")]),a._v(" "),t("p",[a._v("在执行C++代码时，仅凭几个指令即可根据偏移信息获取变量信息，而JavaScript里需要通过字符串匹配来查找属性值的，这就需要更多的操作才能访问到变量信息，而代码量变量存取是十分频繁的，这也就制约了JavaScript的性能。V8借用了类和偏移位置的思想，将本来通过属性名匹配来访问属性值的方法进行了改进，使用类似C++编译器的偏移位置机制来实现，这就是隐藏类。")]),a._v(" "),t("p",[a._v("隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。同时，也可以识别属性不同的对象。")]),a._v(" "),t("p",[a._v("隐藏类转换取决于将属性添加到对象的顺序.----非常重要")]),a._v(" "),t("p",[a._v("下面代码中p1,p2的属性添加顺序不一样，结果就是p1,p2会有两个不同的隐藏类。这种情况下还是最好采用相同的初始化顺序，以便系统可以复用隐藏类，帮助系统提升性能。")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nvar p1 = new Point(1, 2);\np1.a = 5;\np1.b = 6;\nvar p2 = new Point(3, 4);\np2.b = 7;\np2.a = 8;\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("h2",{attrs:{id:"内联缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内联缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" 内联缓存")]),a._v(" "),t("p",[a._v("正常访问对象属性的过程是：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？当然是可行的，这就是内嵌缓存。")]),a._v(" "),t("p",[a._v("内嵌缓存的大致思路就是将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表。")]),a._v(" "),t("p",[a._v("比如以下代码")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('function Point(x,y){\n    this.x=x;\n    this.y=y;\n}\nvar p1 = new Point(1,2);\nvar p2 = new Point(3,4);\np2.x="hello world";\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("p",[a._v("当执行"),t("code",[a._v("p1=new Point(1,2)")]),a._v("与"),t("code",[a._v("p2 = new Point(3,4)")]),a._v("时，使用的同一个隐藏类，当执行"),t("code",[a._v('p2.x="hello world"')]),a._v("时x的类型由int转化成了String，就会新建一个新的隐藏类，所以代码中应该尽量避免此类操作。")]),a._v(" "),t("h2",{attrs:{id:"内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存管理","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),t("p",[a._v("Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。")]),a._v(" "),t("p",[a._v("内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：")]),a._v(" "),t("ul",[t("li",[a._v("Zone：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。")]),a._v(" "),t("li",[a._v("堆：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：\n"),t("ul",[t("li",[a._v("年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。")]),a._v(" "),t("li",[a._v("年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。")]),a._v(" "),t("li",[a._v("大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。")])])])]),a._v(" "),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收","aria-hidden":"true"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("h3",{attrs:{id:"新生代垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾回收","aria-hidden":"true"}},[a._v("#")]),a._v(" 新生代垃圾回收")]),a._v(" "),t("p",[a._v("新生代内存中的垃圾回收主要通过 Scavenge 算法进行，具体实现时主要采用了 Cheney 算法。Cheney 将内存空间一分为二，每部分都叫做一个 Semispace，这两个 Semispace 一个处于使用，一个处于闲置。处于使用中的 Semispace 也叫作 From，处于闲置中的 Semispace 也叫作 To。")]),a._v(" "),t("p",[a._v("在垃圾回收运行时时，会检查 From 中的对象，当某个对象需要被回收时，将其留在 From 空间，剩下的对象移动到 To 空间，然后进行反转，将 From 空间和 To 空间互换。进行垃圾回收时，会将 To 空间的内存进行释放。")]),a._v(" "),t("p",[a._v("简而言之，就是 From 空间中存放不需要被回收的对象，To 空间中存放需要被回收的对象，当垃圾回收运行时，将 To 空间中的对象全部进行回收。")]),a._v(" "),t("p",[a._v("前面说过，新生代内存空间用来存放存活时间较短的对象，老生代内存空间用来存放存活时间较长的对象。新生代中的对象可以晋升到老生代中，具体有两种方式：")]),a._v(" "),t("ul",[t("li",[a._v("在垃圾回收的过程中，如果发现某个对象之前被清理过，那么会将其晋升到老生代内存空间中")]),a._v(" "),t("li",[a._v("在 From 空间和 To 空间进行反转的过程中，如果 To 空间中的使用量已经超过了 25%，那么就将 From 中的对象直接晋升到老生代内存空间中")])]),a._v(" "),t("h3",{attrs:{id:"老生代垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老生代垃圾回收","aria-hidden":"true"}},[a._v("#")]),a._v(" 老生代垃圾回收")]),a._v(" "),t("p",[a._v("对于老生代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。")]),a._v(" "),t("p",[a._v("Mark Sweep 是将需要被回收的对象进行标记，在垃圾回收运行时直接释放相应的地址空间,Mark Compact将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收。")]),a._v(" "),t("h3",{attrs:{id:"触发条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发条件","aria-hidden":"true"}},[a._v("#")]),a._v(" 触发条件")]),a._v(" "),t("p",[a._v("作用域：能形成作用域的函数调用、with 语句 以及 全局作用域。\n闭包：V8 无法主动回收内存中的闭包引用和全局变量引用。")]),a._v(" "),t("h3",{attrs:{id:"内存泄漏原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏原因","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存泄漏原因")]),a._v(" "),t("ul",[t("li",[a._v("全局变量引起的内存泄漏")]),a._v(" "),t("li",[a._v("闭包引起的内存泄漏")]),a._v(" "),t("li",[a._v("dom清空或删除时，事件未清除导致的内存泄漏")])]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("ol",[t("li",[a._v("对类的初始化最好都通过构造函数")]),a._v(" "),t("li",[a._v("对类的属性的类型一开始就确定好，不要随便对属性进行类型更改以便更好的使用隐藏类")]),a._v(" "),t("li",[a._v("减少全局变量的定义")]),a._v(" "),t("li",[a._v("正确的使用闭包，不要无意义地使用闭包")]),a._v(" "),t("li",[a._v("对dom绑定事件，不使用之后要进行赋null")])]),a._v(" "),t("p",[a._v("参考资料:")]),a._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/455d0b9ef0a8",target:"_blank",rel:"noopener noreferrer"}},[a._v("V8 内存管理和垃圾回收机制总结"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/heyeqingquan/article/details/78839699",target:"_blank",rel:"noopener noreferrer"}},[a._v("Chrome V8引擎介绍"),t("OutboundLink")],1)])])])},[],!1,null,null,null);r.default=v.exports}}]);